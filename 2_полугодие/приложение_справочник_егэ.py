import PySimpleGUI as sg

sg.theme('LightBlue2')  # Set the theme

s=['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27']
a=[
'''
1
hl<3''',
'''
2
 1) Сгенерировать всевозможные сочетания переменных

 2) Проверить логическкую функцию на условие
   
 3) Сопоставить вывод с таблицей из задания

    print('x y z w')
    
    for x in range(2):
    
       for y in range(2):
       
          for z in range(2):
          
             for w in range(2):
             
                if (not(y<=x) or (z<=w) or not(z))==False:
                ''',
'''
3
На все таблицы поставить фильтр''',
'''
4
 1) Построить двоичное дерево дерево с известными данными
   
 2) Определить количество нужных для кодировки символов 
   
 3) Начать кодировку с минимальной длины кода. Посмотреть, хватает ли оставшийся вариантов, что закодировать остальное символы
   
 4) Если не хватает вариантов для кодирования оставшихся символов - увеличиваем длину кода''',
'''
5
 1) Организовать цикл перебора с нуля до чила в условии ответа

 2) Перевод в двоичную СС (через bin() или f'{N:b}')
   
 3) Проверяем по условию и проводим манипуляции с числом
   
 4) Переводим в десятичную и проверяем на условия

    chislo=''
    num=(bin(i)[2:])   
    if num.count('1')%2==0:
        chislo='10'+num[2:]+'0'
    if num.count('1')%2!=0:    
        chislo='11'+num[2:]+'1'        
    if int(chislo,2)>40:    
        print (i, int(chislo,2))        
        break
''',
'''
6
 1) вспомнить команды turtle

 2) Нарисовать по алгоритму
   
 3) Поднять перо и нарисовать точки с учётом масштаба
   
 4) Посчитать вручную''',
'''
7
hl<3''',
'''
8
 1)сгенерировать все возможные варианты чисел(for/product)

 2)проверить строчку на условия
   
 3)выводим счетчик значений''',
'''
9
hl<3''',
'''
10
 Открываем расширенный поиск в ворде и ставим галочки у позиций: учитывать регист и всё слово целиком''',
'''
11
hl<3''',
'''
12
 Заменяем числа

    H = "8" * 86
    while "8888" in H or "1111" in H:
        if "1111" in H:
            H = H.replace("1111", "8", 1)
        if "8888" in H:
            H = H.replace("8888", "11", 1)
    print(H)''',
'''
13
 Накопительно нумеруем вершины графа, потом суммируем или умножаем полученные значения ''',
'''
14
 это алфавит дааааааааааааааааааа

 a='0123456789abcd'
 for x in a:
     f=int(f'123{x}5',15)+int(f'1{x}233',15)
     if f%14==0:
         print(f//14)
         break''',
'''
15
for a in range(1, 1000):
   if all((x%2 == 0) <= (x%3 != 0) or (x + a >= 100) for x in range(1, 1000)):
      print(a)
      break''',
'''
16
hl<3''',
'''
17
hl<3''',
'''
18
hl<3''',
'''
19, 20, 21 - 1) Определить точку входа (условие выигрыша, то сколько очков нужно набрать)

             2) Расписать двоичное дерево на четыре хода
             
             3) Ответить на вопрос задачи, присвоив ход игроку
             
             4) Расписывая таблицу на четыре хода, получаем решение всех трёх задач''',
'''
19, 20, 21 - 1) Определить точку входа (условие выигрыша, то сколько очков нужно набрать)

             2) Расписать двоичное дерево на четыре хода
             
             3) Ответить на вопрос задачи, присвоив ход игроку
             
             4) Расписывая таблицу на четыре хода, получаем решение всех трёх задач''',
'''
19, 20, 21 - 1) Определить точку входа (условие выигрыша, то сколько очков нужно набрать)

             2) Расписать двоичное дерево на четыре хода
             
             3) Ответить на вопрос задачи, присвоив ход игроку
             
             4) Расписывая таблицу на четыре хода, получаем решение всех трёх задач''',
'''
22
hl<3''',
'''
23
 1) С помощью функции product сформировать объект со всеми комбинациями искомой строки

 2) for prog in объект
     
 3) возвращаем стартовое значение в первоначальный вид (обнуляем его)
     
 4) используем continue для пропуска итераций неподходящих программ
     
 5) for x in prog - заходим в програму и анализируем команды
     
 6) проводим проверку на условия (if a == 7: break if a >= 35: break)''',
'''
24
hl<3''',
'''
25
hl<3''',
'''
26
hl<3''',
'''
27A - 1) из-за того, что мало станций мы можем использовать перебор

      2) загружаем данные из файла в список
      
      3) избавляемся от первого элемента
      
      4) создаём переменную с некоторыми параметрами нашего списка, такими как длина
      
      5) сдаиваем список
      
      6) успользуя срезы, меняем список для работы таким образом, чтобы км, для которого мы считаем стоимость доставки, всегда стоял на первом месте в списке
      
      7) когда мы создаем новый список на основе среза, мы обнуляем стоимость
      
      8) считаем стоимость доставки по известной (заданной) формуле
      
      9) создаём переменную для пересчёта индекса элементов после середины списка (от длины списка отнимаем индекс элемента)
      
      10) считаем стоимость накоплением
      
      11) найденную стоимость на каждом км добавляем в новый список
      
      12) выводим индекс минимального элемента списка со стоимостью, прибаляя 1

27Б - 1) вместо перебора используем метод итераций (приближения), с каждым шагом приближаемся к точному ответу
      
      2) так же сдвоенный список
      
      3) вся программа находится в бесконечном цикле, выход из которого - точное решение (точное решение - два раза повторяющийся ответ при шаге 1)
      
      4) большой цикл перебора организован с учётом 3 переменных: старта, финиша и шага
      
      5) шаг настраивается таким образом, чтобы было 20 равнораспределённых замеров по всей дороге
      
      6) после каждого прохода большого цикла старт, финиш и шаг пересчитываются (определяем минимальную стоимость и км, которому она принадлежит) 
      
      7) значения старта и финиша - это границы диапазона поиска
      
      8) новое значение границ диапазона поиска это км минимальной стоимости + шаг и км - шаг
      
      9) после перерасчёта старта и финиша перерасчитываемся шаг (целая часть от деления на 10)
      
      10) когда шаг становится == 0, мы присваиваем ему значение 1''',

]
#[sg.Text('Input Text:', font=('Arial', 12)), sg.InputText(key='input')],
    #[sg.Text('Output Text:', font=('Arial', 12)), sg.Text('', size=(40, 1), key='output')],
# Define the layout
layout = [[sg.Combo(s, default_value=s[0], s=(15,22), enable_events=True, readonly=True, k='-COMBO-', key='Combo'),
          sg.Output(s=(40,10), key='outputt')],
          [sg.Button('Process Input', font=('Arial', 12), button_color=('white', '#4CAF50'), key='process'),
           sg.Button('Someth', font=('Arial', 12), button_color=('white', '#4CAF50'), key='button')]]

# Create the window
window = sg.Window('Егоров 0.1', layout)

# Event loop
while True:
    event, values = window.read()

    # Exit the app when the window is closed
    if event == sg.WINDOW_CLOSED:
        break

    # Process the input and update the output when the button is clicked
    if event == 'process':
        #input_text = values['input']
        choice=a[int(values['Combo'])-1]
        #print(choice)
        #window['input'].update('')
        #window['output'].update(input_text)
        window['outputt'].update('')
        window['outputt'].update(choice)
    if event == 'button':
        break

# Close the window
window.close()
